"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Ported from HAAR.js
 * src: https://github.com/foo123/HAAR.js/
 */

function integralCanny(gray, w, h) {
    var i,
        j,
        k,
        sum,
        grad_x,
        grad_y,
        ind0,
        ind1,
        ind2,
        ind_1,
        ind_2,
        count = gray.length,
        lowpass = new Uint8Array(count),
        canny = new Float32Array(count);

    // first, second rows, last, second-to-last rows
    for (i = 0; i < w; i++) {
        lowpass[i] = 0;
        lowpass[i + w] = 0;
        lowpass[i + count - w] = 0;
        lowpass[i + count - w - w] = 0;

        canny[i] = 0;
        canny[i + count - w] = 0;
    }
    // first, second columns, last, second-to-last columns
    for (j = 0, k = 0; j < h; j++, k += w) {
        lowpass[0 + k] = 0;
        lowpass[1 + k] = 0;
        lowpass[w - 1 + k] = 0;
        lowpass[w - 2 + k] = 0;

        canny[0 + k] = 0;
        canny[w - 1 + k] = 0;
    }
    // gauss lowpass
    for (i = 2; i < w - 2; i++) {
        sum = 0;
        for (j = 2, k = w << 1; j < h - 2; j++, k += w) {
            ind0 = i + k;
            ind1 = ind0 + w;
            ind2 = ind1 + w;
            ind_1 = ind0 - w;
            ind_2 = ind_1 - w;

            /*
             Original Code
             
            sum = 0;
            sum += 2 * grayImage[- 2 + ind_2];
            sum += 4 * grayImage[- 2 + ind_1];
            sum += 5 * grayImage[- 2 + ind0];
            sum += 4 * grayImage[- 2 + ind1];
            sum += 2 * grayImage[- 2 + ind2];
            sum += 4 * grayImage[- 1 + ind_2];
            sum += 9 * grayImage[- 1 + ind_1];
            sum += 12 * grayImage[- 1 + ind0];
            sum += 9 * grayImage[- 1 + ind1];
            sum += 4 * grayImage[- 1 + ind2];
            sum += 5 * grayImage[0 + ind_2];
            sum += 12 * grayImage[0 + ind_1];
            sum += 15 * grayImage[0 + ind0];
            sum += 12 * grayImage[i + 0 + ind1];
            sum += 5 * grayImage[0 + ind2];
            sum += 4 * grayImage[1 + ind_2];
            sum += 9 * grayImage[1 + ind_1];
            sum += 12 * grayImage[1 + ind0];
            sum += 9 * grayImage[1 + ind1];
            sum += 4 * grayImage[1 + ind2];
            sum += 2 * grayImage[2 + ind_2];
            sum += 4 * grayImage[2 + ind_1];
            sum += 5 * grayImage[2 + ind0];
            sum += 4 * grayImage[2 + ind1];
            sum += 2 * grayImage[2 + ind2];
            */

            // use as simple fixed-point arithmetic as possible (only addition/subtraction and binary shifts)
            // http://stackoverflow.com/questions/11703599/unsigned-32-bit-integers-in-javascript
            // http://stackoverflow.com/questions/6232939/is-there-a-way-to-correctly-multiply-two-32-bit-integers-in-javascript/6422061#6422061
            // http://stackoverflow.com/questions/6798111/bitwise-operations-on-32-bit-unsigned-ints
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#%3E%3E%3E_%28Zero-fill_right_shift%29
            sum = /*(*/0 + (gray[ind_2 - 2] << 1) + (gray[ind_1 - 2] << 2) + (gray[ind0 - 2] << 2) + gray[ind0 - 2] + (gray[ind1 - 2] << 2) + (gray[ind2 - 2] << 1) + (gray[ind_2 - 1] << 2) + (gray[ind_1 - 1] << 3) + gray[ind_1 - 1] + (gray[ind0 - 1] << 4) - (gray[ind0 - 1] << 2) + (gray[ind1 - 1] << 3) + gray[ind1 - 1] + (gray[ind2 - 1] << 2) + (gray[ind_2] << 2) + gray[ind_2] + (gray[ind_1] << 4) - (gray[ind_1] << 2) + (gray[ind0] << 4) - gray[ind0] + (gray[ind1] << 4) - (gray[ind1] << 2) + (gray[ind2] << 2) + gray[ind2] + (gray[ind_2 + 1] << 2) + (gray[ind_1 + 1] << 3) + gray[ind_1 + 1] + (gray[ind0 + 1] << 4) - (gray[ind0 + 1] << 2) + (gray[ind1 + 1] << 3) + gray[ind1 + 1] + (gray[ind2 + 1] << 2) + (gray[ind_2 + 2] << 1) + (gray[ind_1 + 2] << 2) + (gray[ind0 + 2] << 2) + gray[ind0 + 2] + (gray[ind1 + 2] << 2) + (gray[ind2 + 2] << 1); // &0xFFFFFFFF ) >>> 0;

            /*
            Original Code
            
            grad[ind0] = sum/159 = sum*0.0062893081761006;
            */

            // sum of coefficients = 159, factor = 1/159 = 0,0062893081761006
            // 2^14 = 16384, 16384/2 = 8192
            // 2^14/159 = 103,0440251572322304 =~ 103 +/- 2^13
            //grad[ind0] = (( ((sum << 6)&0xFFFFFFFF)>>>0 + ((sum << 5)&0xFFFFFFFF)>>>0 + ((sum << 3)&0xFFFFFFFF)>>>0 + ((8192-sum)&0xFFFFFFFF)>>>0 ) >>> 14) >>> 0;
            lowpass[ind0] = ((103 * sum + 8192 & 0xFFFFFFFF) >>> 14 & 0xFF) >>> 0;
        }
    }

    // sobel gradient
    for (i = 1; i < w - 1; i++) {
        //sum=0; 
        for (j = 1, k = w; j < h - 1; j++, k += w) {
            // compute coords using simple add/subtract arithmetic (faster)
            ind0 = k + i;
            ind1 = ind0 + w;
            ind_1 = ind0 - w;

            grad_x = 0 - lowpass[ind_1 - 1] + lowpass[ind_1 + 1] - lowpass[ind0 - 1] - lowpass[ind0 - 1] + lowpass[ind0 + 1] + lowpass[ind0 + 1] - lowpass[ind1 - 1] + lowpass[ind1 + 1] //&0xFFFFFFFF
            ;
            grad_y = 0 + lowpass[ind_1 - 1] + lowpass[ind_1] + lowpass[ind_1] + lowpass[ind_1 + 1] - lowpass[ind1 - 1] - lowpass[ind1] - lowpass[ind1] - lowpass[ind1 + 1] //&0xFFFFFFFF
            ;

            //sum += (Abs(grad_x) + Abs(grad_y))&0xFFFFFFFF;
            canny[ind0] = Math.abs(grad_x) + Math.abs(grad_y); //&0xFFFFFFFF;
        }
    }

    // integral canny
    // first row
    i = 0;sum = 0;
    while (i < w) {
        sum += canny[i];
        canny[i] = sum; //&0xFFFFFFFF;
        i++;
    }
    // other rows
    i = w;k = 0;sum = 0;
    while (i < count) {
        sum += canny[i];
        canny[i] = canny[i - w] + sum; //&0xFFFFFFFF;
        i++;k++;if (k >= w) {
            k = 0;sum = 0;
        }
    }

    return canny;
}

exports.default = integralCanny;